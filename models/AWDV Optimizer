import numpy as np
import tensorflow as tf
from typing import Dict, Any, Tuple
from tqdm import tqdm

class AWDVOptimizer:
    """Implementation of Adaptive Weighted Delay Velocity optimization"""
    def __init__(self, model, num_particles: int = 10, max_iter: int = 20):
        self.model = model
        self.num_particles = num_particles
        self.max_iter = max_iter
        
        # PSO-AWDV parameters from paper
        self.alpha = 0.9  # Personal best influence
        self.beta = 0.5   # Global best influence
        self.gamma = 0.3  # Adaptive delay component
        
    def optimize(self, X_train, y_train, X_val, y_val) -> Dict[str, Any]:
        """Run AWDV optimization"""
        # Initialize particles
        particles = self._initialize_particles()
        personal_best = [None] * self.num_particles
        global_best = None
        global_best_score = -np.inf
        
        # Optimization loop
        for iteration in tqdm(range(self.max_iter), desc="AWDV Optimization"):
            for i, particle in enumerate(particles):
                # Train and evaluate with current particle's parameters
                score = self._evaluate_particle(particle, X_train, y_train, X_val, y_val)
                
                # Update personal best
                if personal_best[i] is None or score > personal_best[i]['score']:
                    personal_best[i] = {'params': particle.copy(), 'score': score}
                
                # Update global best
                if score > global_best_score:
                    global_best_score = score
                    global_best = particle.copy()
            
            # Update particle velocities and positions
            particles = self._update_particles(particles, personal_best, global_best)
        
        return global_best
    
    def _initialize_particles(self) -> list:
        """Initialize particles with random hyperparameters"""
        particles = []
        for _ in range(self.num_particles):
            particle = {
                'input_shape': self.model.input_shape,
                'num_classes': self.model.num_classes,
                'num_filters': int(2**np.random.randint(3, 6)),  # 8 to 32
                'kernel_size': int(2**np.random.randint(2, 4)),   # 4 to 8
                'bilstm_units': int(2**np.random.randint(6, 8)),  # 64 to 128
                'num_heads': int(2**np.random.randint(2, 4)),     # 4 to 8
                'head_size': int(2**np.random.randint(5, 7)),     # 32 to 64
                'dense_units': int(2**np.random.randint(5, 7)),   # 32 to 64
                'dropout_rate': np.random.uniform(0.01, 0.2),
                'l2_reg': np.random.uniform(0.01, 0.2),
                'learning_rate': 10**np.random.uniform(-4, -2),
                'batch_size': int(2**np.random.randint(5, 9))     # 32 to 256
            }
            particles.append(particle)
        return particles
    
    def _evaluate_particle(self, params: Dict[str, Any], X_train, y_train, X_val, y_val) -> float:
        """Evaluate a particle's fitness"""
        # Create new model with particle's parameters
        model = MNTDModel(
            input_shape=params['input_shape'],
            num_classes=params['num_classes'],
            num_filters=params['num_filters'],
            kernel_size=params['kernel_size'],
            bilstm_units=params['bilstm_units'],
            num_heads=params['num_heads'],
            head_size=params['head_size'],
            dense_units=params['dense_units'],
            dropout_rate=params['dropout_rate'],
            l2_reg=params['l2_reg']
        )
        
        # Compile and train briefly
        model.compile(learning_rate=params['learning_rate'])
        model.model.fit(
            X_train, y_train,
            batch_size=params['batch_size'],
            epochs=5,  # Short training for evaluation
            verbose=0
        )
        
        # Evaluate on validation set
        _, accuracy = model.model.evaluate(X_val, y_val, verbose=0)
        return accuracy
    
    def _update_particles(self, particles: list, personal_best: list, global_best: Dict[str, Any]) -> list:
        """Update particle positions with AWDV"""
        for i, particle in enumerate(particles):
            # Calculate adaptive delay component
            delay = np.random.rand() * (global_best['score'] - personal_best[i]['score'])
            
            for key in particle.keys():
                if key in ['input_shape', 'num_classes']:  # Don't optimize these
                    continue
                    
                # Calculate velocity components
                cognitive = self.alpha * (personal_best[i]['params'][key] - particle[key])
                social = self.beta * (global_best[key] - particle[key])
                
                # Update with adaptive delay
                velocity = cognitive + social + self.gamma * delay
                
                # Update position
                if isinstance(particle[key], int):
                    particle[key] = max(1, int(particle[key] + velocity))
                else:
                    particle[key] += velocity
            
            # Ensure values stay in valid ranges
            particle['num_filters'] = max(8, min(64, particle['num_filters']))
            particle['kernel_size'] = max(2, min(8, particle['kernel_size']))
            particle['bilstm_units'] = max(32, min(256, particle['bilstm_units']))
            particle['num_heads'] = max(1, min(8, particle['num_heads']))
            particle['head_size'] = max(16, min(128, particle['head_size']))
            particle['dense_units'] = max(16, min(128, particle['dense_units']))
            particle['dropout_rate'] = np.clip(particle['dropout_rate'], 0.01, 0.5)
            particle['l2_reg'] = np.clip(particle['l2_reg'], 0.01, 0.5)
            particle['learning_rate'] = np.clip(particle['learning_rate'], 1e-5, 1e-1)
            particle['batch_size'] = max(16, min(512, particle['batch_size']))
        
        return particles
